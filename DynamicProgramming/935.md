### [935\. Knight Dialer](https://leetcode.com/problems/knight-dialer/)

Difficulty: **Medium**

Related Topics: [Dynamic Programming](https://leetcode.com/tag/dynamic-programming/)

The chess knight has a **unique movement**, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an **L**). The possible movements of chess knight are shown in this diagaram:

A chess knight can move as indicated in the chess diagram below:

![](https://assets.leetcode.com/uploads/2020/08/18/chess.jpg)

We have a chess knight and a phone pad as shown below, the knight **can only stand on a numeric cell** (i.e. blue cell).

![](https://assets.leetcode.com/uploads/2020/08/18/phone.jpg)

Given an integer `n`, return how many distinct phone numbers of length `n` we can dial.

You are allowed to place the knight **on any numeric cell** initially and then you should perform `n - 1` jumps to dial a number of length `n`. All jumps should be **valid** knight jumps.

As the answer may be very large, **return the answer modulo** `10<sup>9</sup> + 7`.

**Example 1:**

```
Input: n = 1
Output: 10
Explanation: We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient.
```

**Example 2:**

```
Input: n = 2
Output: 20
Explanation: All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]
```

**Example 3:**

```
Input: n = 3
Output: 46
```

**Example 4:**

```
Input: n = 4
Output: 104
```

**Example 5:**

```
Input: n = 3131
Output: 136006598
Explanation: Please take care of the mod.
```

**Constraints:**

- `1 <= n <= 5000`

#### Solution

Language: **C++**

```c++
using VL = vector<long>;
using VVL = vector<VL>;
class Solution{
    static const int MOD = 1000000007;
public:
    int knightDialer(int N)
    {
        VVL dp(N + 1, VL(10, 1));
        for (int i{2}; i <= N; ++i)
        {
            dp[i][0] = (dp[i - 1][4] + dp[i - 1][6]) % MOD;
            dp[i][1] = (dp[i - 1][6] + dp[i - 1][8]) % MOD;
            dp[i][2] = (dp[i - 1][7] + dp[i - 1][9]) % MOD;
            dp[i][3] = (dp[i - 1][4] + dp[i - 1][8]) % MOD;
            dp[i][4] = (dp[i - 1][0] + dp[i - 1][3] + dp[i - 1][9]) % MOD;
            dp[i][5] = (0);
            dp[i][6] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][7]) % MOD;
            dp[i][7] = (dp[i - 1][2] + dp[i - 1][6]) % MOD;
            dp[i][8] = (dp[i - 1][1] + dp[i - 1][3]) % MOD;
            dp[i][9] = (dp[i - 1][2] + dp[i - 1][4]) % MOD;
        }
        return accumulate(dp[N].begin(), dp[N].end(), 0L) % MOD;
    }
};
```
